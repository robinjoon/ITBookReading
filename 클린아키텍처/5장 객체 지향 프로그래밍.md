## 객체지향이 무엇인가?

객체지향을 “데이터와 함수의 조합” 이나 “실제 세계를 모델링 하는 새로운 방법” 으로 설명하는 것은 부족하고 모호한 설명이다.

객체지향을 캡슐화, 상속, 다형성을 통해 설명하는 경우도 있다. 이것이 객체지향의 본질인지 알기 위해선 이것들이 무엇인지를 알아야 한다.

## 캡슐화
```
캡슐화는 데이터와 함수를 응집하고, 구분선을 그어 외부에선 내부의 데이터는 은닉되고, 일부 함수들만이 공개되는 것이다.
```

캡슐화는 객체지향 프로그래밍에 국한된 개념이 아니다. 물론, 객체지향 언어에서 캡슐화를 쉽게 할 수 있는 도구들을 제공해주지만, 동시에 캡슐화를 불안전하게 만든다.

C언어에서도 .h 와 .c 를 분리해서 정보를 감추는 것이 가능하다. 오히려 자바에서의 private, public 을 이용한 캡슐화보다 더 강력하다. 

point.h 에 struct 를 선언하고, struct 포인터를 만드는 함수를 선언하고, struct 를 사용하는 함수를 선언한 뒤, point.c 에서 이들을 정의하면, point.h를 include해서 사용하는 main.c 에서는 구조체의 내부에 접근할 수 없다. 심지어, point.c 를 변경하고 싶으면 변경한 뒤 point.c 만 컴파일하면 main.c 은 건들 필요가 없다.

### 결론

**캡슐화는 객체지향의 본질이 아니다.**

## 상속

```
상속은 결국 변수와 함수를 감싸 하나의 유효범위로 묶어서 재정의하는 것이다.
```

객체지향 언어는 상속을 편하게 그리고 안전하게 할 수 있도록 해준다. 하지만, 상속이 객체지향 프로그래밍에 국한된 개념은 아니다. C 언어에서도 구조체와 함수 포인터, 형변환을 사용해 상속을 구현 할(흉내 낼) 수 있다. 다만, 이런 방법은 프로그래머가 이를 의도적으로 따라야만 잘 작동한다는 단점이 있다. 객체지향 언어는 상속을 쉽게 할 수 있도록 해준다.

## 다형성

```
다형성은 다양한 것으로 하나의 것을 할 수 있는 것이다. STDIN, STDOUT 이 그 예시
```

기존에도 함수 포인터를 이용해서 다형성을 할 수 있었지만, 프로그래머가 관례를 잘못 이해하거나 하면, 아주 찾기 힘든 오류를 수정해야 하는 상황이 생긴다. OO는 언어차원에서 상속을 지원해 이를 해결한다.

모든 OO 의 다형성의 근간은 함수포인터다. 폰노이만의 컴퓨팅 시스템에서 프로그래머는 다형적 행위를 수행하기 위해 포인터를 사용해왔다

```
다형성은 어디서든 플러그인 아키텍처를 구현할 수 있게 해주었다.
```

입출력 장치의 드라이버등 운영체제에서는 일찍이 플러그인 아키텍처가 구현되었는데, 개별 프로그래머는 함수 포인터의 위험성 때문에 그러지 않았다. OO는 어디든지 쉽게 플러그인 아키텍처를 구현할 수 있게 해줬다.

## 의존성 역전

```
다형성을 사용하면 함수 호출 트리의 제어 방향과 의존 방향을 반대로 설정할 수 있다.
```

즉, OO 를 사용하면 소프트웨어 아키텍트가 원하는 방향대로 소스 코드 의존성을 설정할 수 있다. 데이터베이스와 사용자 인터페이스가 업무 규칙에 의존하게 할 수 있다. 이는 데이터베이스, 사용자 인터페이스, 업무 규칙 이 **독립적으로 컴파일**할 수 있게 된다. 따라서 **독립적으로 배포**할 수 있고, 서로 다른 팀에서 **독립적으로 개발**할 수 있다.

## 결론

소프트웨어 아키텍트 관점에서, OO는 다형성을 이용해 전체 시스템의 소스코드 의존성에 대한 절대적인 제어권한을 획득할 수 있는 능력이다.